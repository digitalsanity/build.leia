#!/bin/env zsh

SCRIPT_VERSION="1.6.2"

# A simple check to see if you're already running this script.
# It's not bullet proof, but it works.
if [[ ! -f /tmp/.${0:t}.pid ]]; then
	echo "$$" > /tmp/.${0:t}.pid > /dev/null 2>&1
else
	if [[ $( echo $$ ) != $( cat /tmp/.${0:t}.pid ) ]]; then
		echo "You can't run two instances of this script at once!"
		echo "If you have aborted the script, then you must remove /tmp/.${0:t}.pid"
		echo "before you can continue."
		echo "Exiting."
		exit
	fi
fi

# Function: CLEAN_EXIT
# Usage: clean_exit ${0:t}
function clean_exit () {

	# We have to make sure that we get the name "build.leia"
	local NAME
	NAME=$( echo ${1} | cut -d\/ -f1 )

	# We remove the pid file
	rm -f /tmp/.${NAME}.pid > /dev/null 2>&1

	# Then we exit
	exit 0

}

if [[ ! -f ${0:a:h}/etc/${0:t}.conf ]]; then
	echo "Please edit the configuration file located at"
	echo "${0:a:h}/etc/${0:t}.conf.sample"
	echo "and rename it to ${0:t}.conf"
	echo "Script aborted."
	clean_exit ${0:t}
fi

# This function is used to include common sets of files used
#        Function    $1       $2
# Usage: include some/thing ${0:t}
function include () {
	# Edit this path to reflect your installation
  INC_FILE=${HOME}/bin/include/${1}.inc
	if [[ ! -f ${INC_FILE} ]]; then
		INC_OPT=$( echo ${1} | cut -d\/ -f2 )
		echo "Supplied option \"${INC_OPT}\" is not valid."
		echo "Not critical. Will continue and use the default \"--with=clean,addons\"."
	else
		builtin source ${INC_FILE} ${2}
	fi
}

include common/colors
include common/numcpu
include common/input_to_array

# We load the configuration file
# It has to be sourced after "colors" are added since it uses some of
# those variables
builtin source ${0:a:h}/etc/${0:t}.conf

EXTRA_DIR="${INCLUDEDIR}/patches"

# Include the theme file specified in configuration
include themes/${THEME:l}

# Function: LOGGER
# This has to be included after the config file as this contains the path to
# the log file use by loggy
# Usage: loggy <message>
include common/loggy

# We try to find the system language and include it in the script.
# If we don't have the translation for the supplied language, the
# script will ask if the user wants to use en_US for now.
# It is also suggested that the user may want to help out by
# translating this script to their language.
SysLang=$( echo ${LANG} | cut -d= -f2 | cut -d. -f1 | sort -u )

if [[ -f ${INCLUDEDIR}/${0:t}/language/${MyLANG}.inc ]]; then
    include ${0:t}/language/${MyLANG} ${0:t}
    NOLANG=${SysLang}
elif [[ -f ${INCLUDEDIR}/${0:t}/language/${SysLang}.inc ]]; then
    include ${0:t}/language/${SysLang} ${0:t}
    NOLANG=${MyLANG}
else
    echo "\n${WARNING}Could not find a language file for your system language (${NOLANG}).${END}"
    echo "${W}Would you like to continue with English (en_US)? (Y/n)${END} \c"
    read LangAnswer
    if [[ ( ${LangAnswer} == "" || ${LangAnswer} == "Y" || ${LangAnswer} == "y" ) ]]; then
			include ${0:t}/language/en_US ${0:t}
    else
      echo "\n${Y}You decided not to continue. Sorry about that!${END}"
      echo "${W}Please consider translating this script to your language.${END}"
      echo "${W}The language files can be found at"
      echo "${INCLUDEDIR}/${0:t}/language/${END}.\n"
			clean_exit ${0:t}
    fi
fi

# Function: SHOWHELP
# Usage: ShowHelp ${0:t}
function ShowHelp () {
	# When you change the order in the language file, you must also update
	# the number range here.
	for i in {10..30}
	do
		help=Help_${i}
		eval echo \$${help}
	done

	clean_exit ${1}
}

# These are all the defaults set to false
include ${0:t}/defaults

# Show the help information and exit
if [[ ${1} == "--help" ]]; then
	ShowHelp ${0:t}
	clean_exit ${0:t}
fi

KODIVERSION=Leia
KODI=${KODIDIR}/${KODIVERSION}

if ${USE_SUDO} ; then
	SUDO=$( which sudo )
fi

if ${USE_NINJA}; then
		include ${0:t}/ninja
else
	WITH_BUILD_CMD="cmake --build . -- VERBOSE=0 -s -j${NUMCPU}"
	SHOW_CMD="cmake"
fi

MSG="${L_10} ${0:t} v${SCRIPT_VERSION}"
echo "${TIME}[$(date +%T)]${END} ${W}${MSG}${END}"
loggy ${MSG}

# The default behavior is to do a clean,addons install
# Same as build.leia --with=clean,addons
if [[ ! ${@} || ${@} == "" ]] ; then
	
	MSG="${L_100} --with=clean,addons"
	echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
	include ${0:t}/clean
	include ${0:t}/addons

fi

if [[ ${@} =~ "--with" ]]; then

	# Initialze the array in the function InputToArray before use
	# Options are: --with=clean,dirty,addons,no-git,force,only-addons,nn
	InputToArray ${@}
	for i in ${InputArray}
	do
		include ${0:t}/${i}
		if ${STANDALONE} ; then
			break
		fi
	done

	# We default to doing a clean install if these variables are false
	if ( ! ${CLEAN_IS_SET} && ! ${DIRTY_IS_SET} ) && ! ${ONLY_ADDONS} ; then
		MSG="${L_100} --with=clean"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		include ${0:t}/clean
	elif ${ONLY_ADDONS} ; then
		NOGIT_IS_SET=true
	fi

fi

# We check to see if clean and dirty are set at the same time.
# This is not wanted and the script will exit if found.
if ${CLEAN_IS_SET} && ${DIRTY_IS_SET} ; then
	
	echo "${W}**${END} ${WARNING}${L_101}${END} ${W}**${END}"
	echo "${W}**${END} ${WARNING}${L_102} \"${0:t} --help\" ${L_103}${END} \t${W}**${END}"
	echo "${W}**${END} ${WARNING}${L_25}${END} \t\t\t\t\t\t\t${W}**${END}"
	clean_exit ${0:t}
	
fi

# Function: SEPARATOR_LINE
function separator_line () {
	echo "###################################################################" >> ${LOGGYLOGFILE} 2>&1
}
# Function: CHECK_KODIBULD
function check_kodibuild () {

	if [[ ! -d ${KODI}/kodi-build ]]; then
		mkdir ${KODI}/kodi-build > /dev/null 2>&1
	fi

}

# Funtion: REMOVE_KODI
function remove_kodi () {

	if ! ${DISABLE_DELETE_PREFIX} ; then
		if ! ${ONLY_ADDONS} ; then
			if [[ -d ${PREFIX} ]]; then

				MSG="${L_98}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
				loggy ${MSG}
				MSG="${L_97} ${L_81}${END}${Y} \c"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
				read removekodi

				if [[ ${removekodi} == "" || ${removekodi} == "${L_82}" || ${removekodi} == "${L_83}" ]]; then
					MSG="${L_80} ${PREFIX}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
					loggy ${MSG}
					${SUDO} rm -rf ${PREFIX} >> ${LOGGYLOGFILE} 2>&1
				fi
			fi
		fi
	fi

}

# Function: PREPARE_HACK_PRE
function prepare_hack_pre () {
	
	check_kodibuild

	# We copy the original file from backup before we sync with git
	cp -f ${EXTRA_DIR}/SystemInfo.cpp.orig ${KODI}/xbmc/utils/SystemInfo.cpp >> ${LOGGYLOGFILE}
	cp -f ${EXTRA_DIR}/SettingsSystemInfo.xml.orig ${KODI}/addons/skin.estuary/xml/SettingsSystemInfo.xml>> ${LOGGYLOGFILE}

}

# Function: PREPARE_HACK_POST
function prepare_hack_post () {
	
	check_kodibuild

	# We make sure we have the latest version of the file in backup after a git pull
	cp -f ${KODI}/xbmc/utils/SystemInfo.cpp ${EXTRA_DIR}/SystemInfo.cpp.orig >> ${LOGGYLOGFILE}
	cp -f ${KODI}/addons/skin.estuary/xml/SettingsSystemInfo.xml ${EXTRA_DIR}/SettingsSystemInfo.xml.orig >> ${LOGGYLOGFILE}
	
	builtin cd ${KODI}
	
	# We add my hack to enable a personalize System Information screen
	# patch -p0 < ${EXTRA_DIR}/kodi-add-mageia-systeminfo.patch >> ${LOGGYLOGFILE}
	patch -p0 < ${EXTRA_DIR}/add-kekePower-info.patch >> ${LOGGYLOGFILE}
	
}

# Function: FETCH_KODI
function fetch_kodi () {
	
	if [[ ! -d ${KODI} ]]; then
		MSG="${L_104} ${L_81}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG} \c${END}"
		read answer
		
		if [[ ${answer} == "" || ${answer} == "${L_82}" || ${answer} == "${L_83}" ]]; then
			builtin cd ${KODIDIR} > /dev/null 2>&1
			MSG="${L_112} ${L_34}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			git clone -b master ${SOURCE} ${KODIVERSION} >> ${LOGGYLOGFILE} 2>&1
			
			# We need to set a variable here so that we know it's a fresh copy
			FRESH_INSTALL=true
			
			MSG="${L_105} ${L_81}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG} \c${END}"
			read binaryaddons
			
			if [[ ${binaryaddons} == "" || ${binaryaddons} == "${L_82}" || ${binaryaddons} == "${L_83}" ]]; then
				FRESH_ADDON_IS_SET=true
				FRESH_INSTALL=true
			else
				MSG="${L_106}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
				ADDON_IS_SET=false
				FRESH_INSTALL=true
			fi
		else
			MSG="${L_107}"
			echo "\n ${ARROW} ${Y}${MSG} ${KODI}${END}"
			echo "${ARROW} ${Y}git clone ${SOURCE} ${KODIVERSION}${END}"
			MSG="${L_25}"
			echo "${ARROW} ${WARNING}${MSG}${END}"
			clean_exit ${1}
		fi
	fi

}

# Function: CHECK_GIT_FOR_UPDATES
function check_git_for_updates () {

	if [[ $( git rev-parse HEAD ) == $( git ls-remote $( git rev-parse --abbrev-ref @{u} | sed 's/\// /g' ) | cut -f1 ) ]]; then
		UPTODATE=true
	else
		UPTODATE=false
	fi

}
# Function: GIT_PULL
function git_pull () {
	
	# We have to run the prepare_hack_pre function now, before we git pull
	prepare_hack_pre

	if ! ${FRESH_INSTALL} ; then
	if ! ${ONLY_ADDONS} ; then

  if ${FORCE_IS_SET} ; then
		FORCED="(${L_24})"
		GITMSG=false
	else
		FORCED="(${L_25})"
		GITMSG=true
  fi
    
  if ! ${NOGIT_IS_SET} ; then

		# We check if kodi-build exists, if not, create it.
		check_kodibuild

		MSG="${L_20} ${KODIVERSION}${YesForce}"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		builtin cd ${KODI}/kodi-build

		check_git_for_updates

		separator_line

		if ${UPTODATE} ; then

			MSG="${KODIVERSION} ${L_23} ${FORCED}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
			loggy ${MSG}
			if ${GITMSG} ; then
				clean_exit ${1}
			fi

		else

			MSG="${L_21} ${KODIVERSION} ${L_22}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			git pull >> ${LOGGYLOGFILE} 2>&1
			GITMSG=false

		fi
	else
		GITMSG=false
	fi

	fi
	fi

}

# Function: CLEAN_KODI
function clean_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if ! ${GITMSG} || ! ${ONLY_ADDONS} ; then
  
	if ! ${FRESH_INSTALL} ; then
		if ${CLEAN_IS_SET} ; then
			MSG="${L_113}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			
			# We check if kodi-build exists, if not, we create it.
			# It is done at this point as well since this is a point where
			# something could go wrong sometimes. I.e. if you Ctrl-C the script
			# at this point and kodi-build is missing.
			check_kodibuild
			builtin cd ${KODI}
			${SUDO} rm -rf kodi-build > /dev/null 2>&1

		if ! ${DISABLE_CCACHE_Q} ; then

			if ! ${NOCCACHE_IS_SET} ; then
				if [[ $( which ccache ) ]]; then
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_118}${END}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_119}${END}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_117} ${L_81} \c${END}"
					read emptyccache
					if [[ ${emptyccache} == "" || ${emptyccache} == "${L_82}" || ${emptyccache} == "${L_83}" ]]; then
						MSG="${L_116}"
						echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
						loggy ${MSG}
						ccache -C >> ${LOGGYLOGFILE} 2>&1
					fi
				fi
			fi # End of check for no-ccache check

		fi # End of DISABLE_CCACHE_Q from nn.inc

	fi # End of clean check
	else
		if ! ${DISABLE_CCACHE_Q} ; then
			if ! ${CCACHE_IS_SET} ; then
				if [[ $( which ccache ) ]]; then
					MSG="${L_118}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
					MSG="${L_119}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
					MSG="${L_117} ${L_81}}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${W} \c${END}"
					read emptyccache
					if [[ ${emptyccache} == "" || ${emptyccache} == "${L_82}" || ${emptyccache} == "${L_83}" ]]; then
						MSG="${L_116}"
						echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
						loggy ${MSG}
						ccache -C >> ${LOGGYLOGFILE} 2>&1
					fi
				fi
			fi # End of no-ccache check
		fi # End of DISABLE_CCACHE_Q from nn.inc
	fi
fi # End of the GITMSG check

}

# Function: CHECK_FOR_LIBS
function check_for_libs () {
	
	if [[ ! -f /usr/local/lib/libcrossguid.a ]] && [[ ! -f /usr/local/lib64/libcrossguid.a ]] && [[ ! -f /usr/lib/libcrossguid.a ]] && [[ ! -f /usr/lib64/libcrossguid.a ]]; then
		builtin cd ${KODI}
		${SUDO} make -C tools/depends/target/crossguid PREFIX=/usr/local >> ${LOGGYLOGFILE} 2>&1
	fi
	# We have to use libfmt provided by Kodi as the build will fail with others
	if [[ ! -f /usr/local/lib/libfmt.a ]]; then
		builtin cd ${KODI}
		${SUDO} make -C tools/depends/target/libfmt PREFIX=/usr/local >> ${LOGGYLOGFILE} 2>&1
	fi

}

# Function: CCACHE_NOT_FOUND
function ccache_not_found () {

	if [[ ! $( which ccache ) ]]; then
		MSG="${L_114}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
		loggy ${MSG}
		MSG="${L_115}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
		loggy ${MSG}
fi

}

function kodi_downloads () {

	builtin cd ${KODI}/kodi-build
	tar xf ${EXTRA_DIR}/kodi-download.tar.xz

}

# Function: CONFIGURE_KODI
function configure_kodi () {
	
	# We apply my hack for personalized info
	prepare_hack_post
	
	# We check for needed libraries before we continue
	check_for_libs
	
	if ${NOCCACHE_IS_SET} ; then
		EXTRA_OPTIONS="-DENABLE_CCACHE:BOOL=OFF"
	fi
	
	# We use this function here to print a message that ccache was not found
	ccache_not_found

	# We try to find the Freetype2 include directory and add it to the configuration part
	FIND_FREETYPE_INCLUDE=$( pkg-config --cflags --libs freetype2 | awk '{print $1}' | cut -dI -f2 )
	
		if ${FRESH_INSTALL} ; then
			MSG="${L_31} ${KODIVERSION} ${L_37}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			check_kodibuild
			builtin cd ${KODI}/kodi-build
			
			# We add the tarballs that the installation automatically downloads
			kodi_downloads
			export ${CMAKE_FLAGS}
			cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} ${EXTRA_OPTIONS} -DENABLE_APP_AUTONAME=ON -DFREETYPE_INCLUDE_DIR=${FIND_FREETYPE_INCLUDE} -DGIT_VERSION=\"${MY_GIT_VERSION}\">> ${LOGGYLOGFILE} 2>&1
			separator_line
		else
			check_kodibuild
			if ${CLEAN_IS_SET} && ! ${DIRTY_IS_SET} ; then
				MSG="${L_31} ${KODIVERSION} ${L_38}"
				echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
				export ${CMAKE_FLAGS}
				cmake .. ${WITH_BUILD} -DCMAKE_INSTALL_PREFIX=${PREFIX} ${EXTRA_OPTIONS} -DENABLE_APP_AUTONAME=ON -DFREETYPE_INCLUDE_DIR=${FIND_FREETYPE_INCLUDE} -DGIT_VERSION=\"${MY_GIT_VERSION}\" >> ${LOGGYLOGFILE} 2>&1
			elif ${DIRTY_IS_SET} && ! ${CLEAN_IS_SET} ; then
				MSG="${L_30} ${KODIVERSION} ${L_39}"
				echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				# builtin cd ${KODI}/kodi-build
			fi
		fi

}

# Function: CHECK_FOR_KODI_BIN
function check_for_kodi_bin () {

	# local APP_NAME=$( builtin cd ${KODI}/kodi-build/; ls kodi* | grep -v xrandr )
	# if [[ ! -f ${KODI}/kodi-build/${APP_NAME} ]]; then
	if [[ ! -f $( builtin cd ${KODI}/kodi-build/; ls kodi* | grep -v xrandr ) ]]; then
		MSG="${L_35} ${KODIVERSION} ${L_36}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
		loggy ${MSG}
		FAILED=true
	else
		FAILED=false
	fi

}
# Function: BUILD_KODI
function build_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if ( ! ${GITMSG} || ${FORCE_IS_SET} ) && ! ${ONLY_ADDONS} ; then

	MSG="${L_30} ${KODIVERSION}"
	loggy ${MSG}
		
	MSG="${L_33} ${KODIVERSION}. ${L_34}"
	echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
	builtin cd ${KODI}/kodi-build
	export CFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH} -fstack-protector --param=ssp-buffer-size=4"
	export CXXFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH} -fstack-protector --param=ssp-buffer-size=4"
	export CPPFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH} -D_FORTIFY_SOURCE=2 -fstack-protector --param=ssp-buffer-size=4"
	export MAKEFLAGS="-s -j${NUMCPU}"
	${WITH_BUILD_CMD} >> ${LOGGYLOGFILE} 2>&1 &
	
	if [[ ${SHOW_CMD} == "ninja" ]]; then
		while pidof ${SHOW_CMD} > /dev/null 2>&1
		do
			NUMBERS=($( grep "^\[" ${LOGGYLOGFILE} | awk '{print $1}' | tail -1 | sed -e "s/\[//g" -e "s/\]//g" -e 's/\//\ /g' ))
			MSG=$(( ${NUMBERS[1]}*100/${NUMBERS[2]} ))
			echo -ne "${TIME}[$(date +%T)]${END} ${Y}${L_99}${MSG}%${END}"\\r
		done
	else
		while pidof cmake > /dev/null 2>&1
		do
				MSG=$( grep "^\[" ${LOGGYLOGFILE} | grep "\%" | awk '{print $1}' | tail -1 | cut -d\] -f1 | grep -v Download | sed -e 's/Built//g' -e 's/Linking//g' -e 's/\[//g' -e 's/%//g' )
				echo -ne "${TIME}[$(date +%T)]${END} ${Y}${L_99}${MSG}%${END}"\\r
		done
	fi

	check_for_kodi_bin

# End of the GITMSG check
fi

}

# Function: INSTALL_KODI
function install_kodi () {

  if ! ${FAILED} ; then
		MSG="${L_90} ${PREFIX}"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		builtin cd ${KODI}/kodi-build
		if [[ ${SHOW_CMD} == "ninja" ]]; then
			${SUDO} ${WITH_BUILD_CMD} install >> ${LOGGYLOGFILE} 2>&1
		else
			${SUDO} make -s install -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1
		fi
		separator_line
	elif ${FAILED} && ! ${ONLY_ADDONS} ; then
		MSG="${L_110} ${KODIVERSION} ${L_111} ${L_25}"
		echo "${TIME}[$(date +%T)]${END} ${WARNING}${MSG}${END}"
		loggy ${MSG}
		if ${FAILED} ; then
			clean_exit ${1}
		fi
	fi

}

# Function: INSTALL_ADDONS
function install_addons () {

# This is basically a hack to make addons install work during a fresh install
# without changing too much of the code.
if ( ${FRESH_ADDON_IS_SET} && ${FRESH_INSTALL} ) ; then
	FRESH_INSTALL=false
fi

if ! ${FRESH_INSTALL} ; then

	if ${ADDON_IS_SET} && ${DIRTY_IS_SET} ; then
		CLEAN_IS_SET=true
		ADDONS=" (${L_38:u})"
	fi

	if ${ONLY_ADDONS} ; then
		ADDON_IS_SET=true
		if [[ -f ${PREFIX}/bin/kodi ]]; then
			FAILED=false
		else
			FAILED=true
		fi
		CLEAN_IS_SET=true
		ADDONS=" ${L_95}"
	fi

	if ${ADDON_IS_SET} ; then
		if ! ${FAILED} ; then
			if ${CLEAN_IS_SET} ; then
				MSG="${L_91}${ADDONS}"
				echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				builtin cd ${KODI}
				${SUDO} make -s -C \
				tools/depends/target/binary-addons \
				distclean \
				> /dev/null 2>&1
			fi

			MSG="${L_92}${ADDONS}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
		
			# This is a test to see if it is possible to speed up the compilation of
			# the binary addons. Looks like some of them are using all of the availble
			# CPUS/threads, while others don't.
			# Don't think I'll be able to do anything about it.
			export MAKEFLAGS="-s -j${NUMCPU}"
			export CFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH}"
			export CXXFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH}"
			export CPPFLAGS="-D_FORTIFY_SOURCE=2"
			${SUDO} export MAKEFLAGS="-s -j${NUMCPU}" > /dev/null 2>&1
			${SUDO} export CFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH}" > /dev/null 2>&1
			${SUDO} export CXXFLAGS="-O3 -ffast-math -march=${MY_CPU_ARCH} -mtune=${MY_CPU_ARCH}" > /dev/null 2>&1
			${SUDO} export CPPFLAGS="-D_FORTIFY_SOURCE=2" > /dev/null 2>&1
			${SUDO} make -j${NUMCPU} -C \
			tools/depends/target/binary-addons \
			PREFIX=${PREFIX} \
			>> ${LOGGYLOGFILE} 2>&1
			NOTBUILT=( $( grep "Following Addons failed to build: " ${LOGGYLOGFILE} | tail -1 | cut -d: -f2 ) )
			if [[ ! ${NOTBUILT} == "" ]]; then
				MSG="${L_94}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
				for i in ${NOTBUILT}
				do
					echo "${TIME}[$(date +%T)]${END} ${W}**${END} ${WARNING}${i}${END}"
				done
			fi
		else
			MSG="${L_96} ${L_102} \"build.leia --help\" ${L_103}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
			loggy ${MSG}
			clean_exit ${1}
		fi
	elif ! ${ADDON_IS_SET} && ${FRESH_INSTALL} ; then
		MSG="${L_93}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
		loggy ${MSG}
	fi

fi

}

# Here we run all of our functions in turn
fetch_kodi ${0:t}
git_pull ${0:t}
clean_kodi ${0:t}
remove_kodi ${0:t}
configure_kodi ${0:t}
build_kodi ${0:t}
install_kodi ${0:t}
install_addons ${0:t}

separator_line
echo "#             End of compilation for ${KODIVERSION}                         #" >> ${LOGGYLOGFILE}
separator_line
echo "${TIME}[$(date +%T)]${END} ${Y}${L_120}:${END}"
echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${PREFIX}/bin/kodi${END}"
echo "${TIME}[$(date +%T)]${END} ${Y}${L_121}:${END}"
echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${LOGGYLOGFILE}${END}"

clean_exit ${0:t}

#!/bin/zsh

SCRIPT_VERSION="1.4.5"

if [[ ! -f /tmp/.${0:t}.pid ]]; then
	echo "$$" > /tmp/.${0:t}.pid > /dev/null 2>&1
else
	if [[ $( echo $$ ) != $( cat /tmp/.${0:t}.pid ) ]]; then
		echo "You can't run two instances of this script at once!"
		echo "Unless you have aborted the script, then you must remove /tmp/.${0:t}.pid"
		echo "before you can continue."
		echo "Exiting."
		exit
	fi
fi

if [[ ! -f ${0:a:h}/etc/${0:t}.conf ]]; then
	echo "Please edit the configuration file located at"
	echo "${0:a:h}/etc/${0:t}.conf.sample"
	echo "and rename it to ${0:t}.conf"
	echo "Script aborted."
	rm -f /tmp/.${0:t}.pid
	exit
fi

# This function is used to include common sets of files used
# Edit the path to reflect your installation
function include () {
  INC_FILE=${HOME}/bin/include/${1}.inc
	if [[ ! -f ${INC_FILE} ]]; then
		INC_OPT=$( echo ${1} | cut -d\/ -f2 )
		echo "Supplied option \"${INC_OPT}\" is not valid."
		echo "Not critical. Will continue and use the default \"--with=clean,addons\"."
	else
		. ${INC_FILE}
	fi
}

include common/colors
include common/numcpu
include common/input_to_array

# We load the configuration file
# It has to be sourced after "colors" are added since it uses some of
# those variables
. ${0:a:h}/etc/${0:t}.conf

# Include the theme file specified in configuration
include themes/${THEME:l}

# Function: LOGGER
# This has to be included after the config file as this contains the path to
# the log file use by loggy
# Usage: loggy <message>
include common/loggy

# We try to find the system language and include it in the script.
# If we don't have the translation for the supplied language, the
# script will ask if the user wants to use en_US for now.
# It is also suggested that the user may want to help out by
# translating this script to their language.
SysLang=$( echo ${LANG} | cut -d= -f2 | cut -d. -f1 | sort -u )

if [[ -f ${INCLUDEDIR}/${0:t}/language/${MyLANG}.inc ]]; then
    include ${0:t}/language/${MyLANG} ${0:t}
    NOLANG=${SysLang}
elif [[ -f ${INCLUDEDIR}/${0:t}/language/${SysLang}.inc ]]; then
    include ${0:t}/language/${SysLang} ${0:t}
    NOLANG=${MyLANG}
else
    echo "\n${WARNING}Could not find a language file for your system language (${NOLANG}).${END}"
    echo "${W}Would you like to continue with English (en_US)? (Y/n)${END} \c"
    read LangAnswer
    if [[ ( ${LangAnswer} == "" || ${LangAnswer} == "Y" || ${LangAnswer} == "y" ) ]]; then
			include ${0:t}/language/en_US ${0:t}
    else
      echo "\n${Y}You decided not to continue. Sorry about that!${END}"
      echo "${W}Please consider translating this script to your language.${END}"
      echo "${W}The language files can be found at"
      echo "${INCLUDEDIR}/${0:t}/language/${END}.\n"
			rm -f /tmp/.${0:t}.pid
      exit
    fi
fi

function ShowHelp () {
	# Usage: ShowHelp ${0:t}
	# When you change the order in the language file, you must also update
	# the number range here.

	for i in {10..30}
	do
		help=Help_${i}
		eval echo \$${help}
	done

	rm -f /tmp/.build.leia.pid
	exit
}

# We set all the variables used to false
ADDON_IS_SET=false
CLEAN_IS_SET=false
DIRTY_IS_SET=false
FORCE_IS_SET=false
NOGIT_IS_SET=false
FRESH_INSTALL=false
ONLY_ADDONS=false
NOCCACHE_IS_SET=false
GITMSG=false

# Show the help information and exit
if [[ ${1} == "--help" ]]; then
	ShowHelp ${0:t}
	rm -f /tmp/.build.leia.pid
	exit
fi

KODIVERSION=Leia
KODI=${KODIDIR}/${KODIVERSION}

if ${USE_SUDO} ; then
	SUDO=$( which sudo )
fi

MSG="${L_10} ${0:t} v${SCRIPT_VERSION}"
echo "${TIME}[$(date +%T)]${END} ${W}${MSG}${END}"
loggy ${MSG}

# The default behavior is to do a clean,addons install
# Same as build.leia --with=clean,addons
if [[ ! ${@} || ${@} == "" ]] ; then
	MSG="${L_100} --with=clean,addons"
	echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
	include ${0:t}/clean
	include ${0:t}/addons
elif [[ ${@} =~ "--with" ]]; then

	# Initialze the array in the function InputToArray before use
	# Options are: --with=clean,dirty,addons,no-git,force,only-addons
	InputToArray ${@}
	for i in ${InputArray}
	do
		include ${0:t}/${i}
	done

	# We default to doing a clean install if these variables are false
	if ( ! ${CLEAN_IS_SET} && ! ${DIRTY_IS_SET} ) && ! ${ONLY_ADDONS} ; then
		MSG="${L_100} --with=clean"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		include ${0:t}/clean
	elif ${ONLY_ADDONS} ; then
		NOGIT_IS_SET=true
	fi

fi

# We check to see if clean and dirty are set at the same time.
# This is not wanted and the script will exit if found.
if ${CLEAN_IS_SET} && ${DIRTY_IS_SET} ; then
	echo "${W}**${END} ${WARNING}${L_101}${END} ${W}**${END}"
	echo "${W}**${END} ${WARNING}${L_102} \"${0:t} --help\" ${L_103}${END} \t${W}**${END}"
	echo "${W}**${END} ${WARNING}${L_25}${END} \t\t\t\t\t\t\t${W}**${END}"
	rm -f /tmp/.build.leia.pid
	exit
fi

# Funtion: REMOVE_KODI
function remove_kodi () {

	MSG="${L_97} ${L_81} \c"
	echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
	loggy ${MSG}
	read removekodi
	
	if [[ ${removekodi} == "" || ${removekodi} == "${L_82}" || ${removekodi} == "${L_83}" ]]; then
		MSG="${L_80} ${PREFIX}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
		loggy ${MSG}
		${SUDO} rm -rf ${PREFIX} >> ${LOGGYLOGFILE} 2>&1
	fi

}
# Function: FETCH_KODI
function fetch_kodi () {
	if [[ ! -d ${KODI} ]]; then
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_104} ${L_81}${END} \c"
		read answer
		
		if [[ ${answer} == "" || ${answer} == "${L_82}" || ${answer} == "${L_83}" ]]; then
			builtin cd ${KODIDIR} > /dev/null 2>&1
			MSG="${L_112}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			git clone -b master ${SOURCE} ${KODIVERSION} >> ${LOGGYLOGFILE} 2>&1
			
			# We need to set a variable here so that we know it's a fresh copy
			FRESH_INSTALL=true
			
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_105} ${L_81}${END} \c"
			read binaryaddons
			
			if [[ ${binaryaddons} == "" || ${binaryaddons} == "${L_82}" || ${binaryaddons} == "${L_83}" ]]; then
				ADDON_IS_SET=true
			else
				MSG="${L_106}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
				ADDON_IS_SET=false
			fi
		else
			MSG="${L_107}"
			echo "\n ${ARROW} ${Y}${MSG} ${KODI}${END}"
			echo "${ARROW} ${Y}git clone ${SOURCE} ${KODIVERSION}${END}"
			MSG="${L_25}"
			echo "${ARROW} ${WARNING}${MSG}${END}"
			rm -f /tmp/.build.leia.pid
			exit
		fi
	fi
}

# Function: GIT_PULL
function git_pull () {
if ( ! ${FRESH_INSTALL} || ! ${ONLY_ADDONS} ) ; then
	
  if ${FORCE_IS_SET} ; then
		FORCED="(${L_24})"
		GITMSG=false
	else
		FORCED="(${L_25})"
		GITMSG=true
  fi
    
  if ! ${NOGIT_IS_SET} ; then

		MSG="${L_20} ${KODIVERSION}${YesForce}"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		builtin cd ${KODI}/kodi-build
		if [[ $(git rev-parse HEAD) == $(git ls-remote $(git rev-parse --abbrev-ref @{u} | sed 's/\// /g') | cut -f1) ]]; then
			UPTODATE=true
		else
			UPTODATE=false
		fi
		echo "##############################################################" >> ${LOGGYLOGFILE} 2>&1
		if ${UPTODATE} ; then

			MSG="${KODIVERSION} ${L_23} ${FORCED}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
			loggy ${MSG}
			if ${GITMSG} ; then
				rm -f /tmp/.build.leia.pid
				exit
			fi

		else

			MSG="${L_21} ${KODIVERSION} ${L_22}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			git pull >> ${LOGGYLOGFILE} 2>&1
			GITMSG=false

		fi
	else
		GITMSG=false
	fi

fi
}

# Function: CLEAN_KODI
function clean_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if ! ${GITMSG} ; then
  
	if ! ${FRESH_INSTALL} ; then
		if ${CLEAN_IS_SET} ; then
			MSG="${L_113}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			rm -rf kodi-build > /dev/null 2>&1
			mkdir kodi-build > /dev/null 2>&1
	
		if ! ${NOCCACHE_IS_SET} ; then
			if [[ $( which ccache ) ]]; then
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_118}${END}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_119}${END}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${L_117} ${L_81}${END} \c"
				read emptyccache
				if [[ ${emptyccache} == "" || ${emptyccache} == "${L_82}" || ${emptyccache} == "${L_83}" ]]; then
					MSG="${L_116}"
					echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
					loggy ${MSG}
					ccache -C >> ${LOGGYLOGFILE} 2>&1
				fi
			fi
		fi # End of check for no-ccache check

	# Ask if user wants to remove ${PREFIX} before installing
	remove_kodi

	fi # End of clean check
	else
	if ! ${CCACHE_IS_SET} ; then
		if [[ $( which ccache ) ]]; then
			MSG="${L_118}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
			MSG="${L_119}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END}"
			MSG="${L_117} ${L_81}}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${Y}${MSG}${END} \c"
			read emptyccache
			if [[ ${emptyccache} == "" || ${emptyccache} == "${L_82}" || ${emptyccache} == "${L_83}" ]]; then
				MSG="${L_116}"
				echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
				loggy ${MSG}
				ccache -C >> ${LOGGYLOGFILE} 2>&1
			fi
		fi
	fi # End of no-ccache check
	fi
fi # End of the GITMSG check

}

# Function: CONFIGURE_KODI
function configure_kodi () {
	
	if ${NOCCACHE_IS_SET} ; then
		EXTRA_OPTIONS="-DENABLE_CCACHE:BOOL=OFF"
	fi
	
	if [[ ! $( which ccache ) ]]; then
		MSG="${L_114}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
    loggy ${MSG}
		MSG="${L_115}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
    loggy ${MSG}
	fi

		if ${FRESH_INSTALL} ; then
			MSG="${L_31} ${KODIVERSION} ${L_37}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			mkdir kodi-build > /dev/null 2>&1
			builtin cd ${KODI}/kodi-build
			export ${CMAKE_FLAGS}
			cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} ${EXTRA_OPTIONS} >> ${LOGGYLOGFILE} 2>&1
			loggy "###########################################################"
		else
			if ${CLEAN_IS_SET} && ! ${DIRTY_IS_SET} ; then
				MSG="${L_31} ${KODIVERSION} ${L_38}"
				echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
				export ${CMAKE_FLAGS}
				cmake .. -DCMAKE_INSTALL_PREFIX=${PREFIX} ${DISABLE_CCACHE} >> ${LOGGYLOGFILE} 2>&1
			elif ${DIRTY_IS_SET} && ! ${CLEAN_IS_SET} ; then
				MSG="${L_30} ${KODIVERSION} ${L_39}"
				echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
				loggy ${MSG}
				builtin cd ${KODI}/kodi-build
			fi
		fi

}

# Function: BUILD_KODI
function build_kodi () {

# We check if we have a message from git_pull. If not, we continue the build
if ! ${GITMSG} || ${FORCE_IS_SET} && ! ${ONLY_ADDONS} ; then

	MSG="${L_30} ${KODIVERSION}"
	loggy ${MSG}
		
	MSG="${L_33} ${KODIVERSION}. ${L_34}"
	echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
	loggy ${MSG}
	builtin cd ${KODI}/kodi-build
	cmake --build . -- VERBOSE=0 -s -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1

	if [[ ! -f ${KODI}/kodi-build/kodi.bin ]]; then
		MSG="${L_35} ${KODIVERSION} ${L_36}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
		loggy ${MSG}
		FAILED=true
	else
		FAILED=false
	fi

# End of the GITMSG check
fi

}

# Function: INSTALL_KODI
function install_kodi () {

  if ! ${FAILED} ; then
		MSG="${L_90} ${PREFIX}"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		builtin cd ${KODI}/kodi-build
		${SUDO} make -s install -j${NUMCPU} >> ${LOGGYLOGFILE} 2>&1
		echo "#########################################################" >> ${LOGGYLOGFILE} > /dev/null 2>&1
	elif ${FAILED} && ! ${ONLY_ADDONS} ; then
		MSG="${L_110} ${KODIVERSION} ${L_111} ${L_25}"
		echo "${TIME}[$(date +%T)]${END} ${WARNING}${MSG}${END}"
		loggy ${MSG}
		if ${FAILED} ; then
			rm -f /tmp/.build.leia.pid
			exit
		fi
	fi

}

# Function: INSTALL_ADDONS
function install_addons () {
	
if ${ADDON_IS_SET} && ${DIRTY_IS_SET} ; then
	CLEAN_IS_SET=true
	ADDONS=" (${L_38:u})"
fi

if ${ONLY_ADDONS} ; then
	ADDON_IS_SET=true
	if [[ -f ${PREFIX}/bin/kodi ]]; then
		FAILED=false
	else
		FAILED=true
	fi
	CLEAN_IS_SET=true
	ADDONS=" ${L_95}"
fi

if ${ADDON_IS_SET} ; then
	if ! ${FAILED} ; then
		if ${CLEAN_IS_SET} ; then
			MSG="${L_91}${ADDONS}"
			echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
			loggy ${MSG}
			builtin cd ${KODI}
			${SUDO} make -s -C \
			tools/depends/target/binary-addons \
			distclean \
			> /dev/null 2>&1
		fi

		MSG="${L_92}${ADDONS}"
		echo "${TIME}[$(date +%T)]${END} ${INFO}${MSG}${END}"
		loggy ${MSG}
		${SUDO} make -s -j${NUMCPU} -C \
		tools/depends/target/binary-addons \
		PREFIX=${PREFIX} \
		>> ${LOGGYLOGFILE} 2>&1
		NOTBUILT=$( grep "Following Addons failed to build" ${LOGGYLOGFILE} | tail -1 | cut -d: -f2 )
		if [[ ! ${NOTBUILT} == "" ]]; then
			MSG="${L_94}:"
			echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
			MSG="${NOTBUILT}"
			echo "${TIME}[$(date +%T)]${END} ${ARROW}${WARNING}${MSG}${END}"
		fi
	else
		MSG="${L_96} ${L_102} \"build.leia --help\" ${L_103}"
		echo "${TIME}[$(date +%T)]${END} ${ARROW} ${WARNING}${MSG}${END}"
		loggy ${MSG}
		rm -f /tmp/.build.leia.pid
		exit
	fi
elif ! ${ADDON_IS_SET} && ${FRESH_INSTALL} ; then
	MSG="${L_93}"
	echo "${TIME}[$(date +%T)]${END} ${ARROW} ${OTHER}${MSG}${END}"
	loggy ${MSG}
fi
}

# Here we run all of our functions in turn
fetch_kodi
git_pull
clean_kodi
configure_kodi
build_kodi
install_kodi
install_addons

echo "###################################################################" >> ${LOGGYLOGFILE}
echo "#             End of compilation for ${KODIVERSION}                         #" >> ${LOGGYLOGFILE}
echo "###################################################################" >> ${LOGGYLOGFILE}
echo "${TIME}[$(date +%T)]${END} ${Y}${L_120}: ${PREFIX}/bin/kodi${END}"
echo "${TIME}[$(date +%T)]${END} ${Y}${L_121}: ${LOGGYLOGFILE}${END}"

rm -f /tmp/.${0:t}.pid
